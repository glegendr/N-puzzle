<!DOCTYPE html>
<meta charset="utf-8">
<head>
<style>

.node circle {
  fill: #999;
}

.node text {
  font: 10px sans-serif;
}

.node--internal circle {
  fill: #555;
}

.node--internal text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.link {
  fill: none;
  /* stroke: #555; */
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

.flex-container {
  /* We first create a flex layout context */
  display: flex;
  
  /* Then we define the flow direction 
     and if we allow the items to wrap 
   * Remember this is the same as:
   * flex-direction: row;
   * flex-wrap: wrap;
  j */
  flex-flow: row wrap;
  
  /* Then we define how is distributed the remaining space */
  justify-content: space-around;
  
  padding: 0;
  margin: 0;
  list-style: none;
}

.flex-item {
  background: rgb(255, 38, 0);
  padding: 5px;
  width: 200px;
  height: 150px;
  margin-top: 10px;
  line-height: 150px;
  color: white;
  font-weight: bold;
  font-size: 3em;
  text-align: center;
}

</style>
</head>
<body>
<ul class="flex-container">
  <svg id="Manhattan" width="960" height="1060"></svg>
  <svg id="Manhattan3" width="960" height="1060"></svg>
  <svg id="Manhattan8" width="960" height="1060"></svg>
</ul>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

const jsonArray = [{id: "Manhattan", json: "manhattan.json"}, {id: "Manhattan3", json: "manhattan3.json"}, {id: "Manhattan8", json: "manhattan8.json"}] 

for (const element of jsonArray) {
  console.log(element);
  let svg = d3.select('#' + element.id),
      width = +svg.attr("width"),
      height = +svg.attr("height"),
      g = svg.append("g").attr("transform", "translate(" + (width / 2 + 40) + ",400)");

  let tree = d3.tree()
      .size([2 * Math.PI, 300])
      .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });

  d3.json(element.json, function(error, data) {
    if (error) throw error;

    let root = tree(d3.hierarchy(data));

    let link = g.selectAll(".link")
      .data(root.links())
      .enter().append("path")
        .attr("class", "link")
        .style("stroke", function(d) {3
          let color;
          switch (d.target.data.name) {
            case "Right":
              color = "#b34f6a"
              break ;
            case "Left":
              color = "#51823a"
              break ;
            case "Up":
              color = "#447494"
              break ;
            case "Down":
              color = "#9e6745"
              break ;
          }
          return (d.target.data.finish ? "#cad" : color);
        })
        .attr("d", d3.linkRadial()
            .angle(function(d) { return d.x; })
            .radius(function(d) { return d.y; }));

    let node = g.selectAll(".node")
      .data(root.descendants())
      .enter().append("g")
        .attr("class", function(d) { return "node" + (d.children ? " node--internal" : " node--leaf"); })
        .attr("transform", function(d) { return "translate(" + radialPoint(d.x, d.y) + ")"; });

    node.append("circle")
        .attr("r", function(d) { return (d.data.finish ? 2.5 : d.children ? 0 : 2.5); })
        .style("fill", function(d) { return (d.data.finish ? "#f00" : "#555"); });

    svg.append("text")
        .attr("x", (width / 2))             
        .attr("y", 50)
        .attr("text-anchor", "middle")  
        .style("font-size", "16px") 
        .style("text-decoration", "underline")  
        .text(element.id);
    
    node.append("text")
      .attr("dy", "0.31em")
      .attr("x", function(d) { return d.x < Math.PI === !d.children ? 6 : -6; })
      .attr("text-anchor", function(d) { return d.x < Math.PI === !d.children ? "start" : "end"; })
      .attr("transform", function(d) { return "rotate(" + (d.x < Math.PI ? d.x - Math.PI / 2 : d.x + Math.PI / 2) * 180 / Math.PI + ")"; })
      .text(function(d) {
    			return (d.children ? "" : d.data.finish ? d.data.depth : "")
  		});

  });
}

function radialPoint(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

</script>
</body>
</html>